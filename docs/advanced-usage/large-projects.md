---
description: 学习有效使用 Roo Code 处理大型代码库的策略。管理上下文限制，优化令牌使用，并处理复杂的重构任务。
keywords:
  - 大型项目
  - 上下文管理
  - 令牌优化
  - 代码库重构
  - Roo Code 可扩展性
image: /img/social-share.jpg
---

# 处理大型项目

Roo Code 可以用于任何大小的项目，但大型项目需要额外的关注来有效管理上下文。以下是一些处理大型代码库的提示：

---

## 理解上下文限制

Roo Code 使用具有有限“上下文窗口”的大型语言模型 (LLM)。这是模型一次可以处理的最大文本量（以令牌衡量）。如果上下文太大，模型可能无法理解您的请求或生成准确的响应。

上下文窗口包括：

*   系统提示（Roo Code 的指令）。
*   对话历史。
*   您使用 `@` 提及的任何文件的内容。
*   Roo Code 使用的任何命令或工具的输出。

---

## 管理上下文的策略

1.  **具体化：** 提及文件或代码时，请使用具体的文件路径和函数名称。避免使用“主文件”等模糊引用。

2.  **有效使用上下文提及：** 使用 `@/path/to/file.ts` 包含特定文件。使用 `@problems` 包含当前错误和警告。使用 `@` 后跟提交哈希引用特定的 Git 提交。

3.  **分解任务：** 将大型任务分解为更小、更易管理的子任务。这有助于保持上下文的集中。

4.  **总结：** 如果您需要引用大量代码，请考虑在提示中总结相关部分，而不是包含整个代码。

5.  **优先考虑最近的历史：** Roo Code 会自动截断对话历史中的较旧消息以保持在上下文窗口内。请注意这一点，并在需要时重新包含重要上下文。

6.  **使用提示缓存（如果可用）：** 一些 API 提供商如 Anthropic、OpenAI、OpenRouter 和 Requesty 支持“提示缓存”。这会缓存您的提示以供未来任务使用，并有助于降低请求的成本和延迟。

---

## 示例：重构大型文件

假设您需要重构一个大型 TypeScript 文件 (`src/components/MyComponent.tsx`)。以下是一种可能的方法：

1.  **初始概览：**
    ```
    @/src/components/MyComponent.tsx 列出此文件中的函数和类。
    ```

2.  **针对特定函数：**
    ```
    @/src/components/MyComponent.tsx 重构 `processData` 函数以使用 `async/await` 而不是 Promises。
    ```

3.  **迭代更改：** 进行小的、渐进的更改，逐步审查和批准每个步骤。

通过分解任务并提供具体上下文，即使上下文窗口有限，您也可以有效地处理大型文件。