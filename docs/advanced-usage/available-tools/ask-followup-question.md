---
描述: 使用 ask_followup_question 工具在 Roo Code 中实现交互式通信，以收集澄清信息和用户偏好。
关键词:
  - ask_followup_question
  - 用户交互
  - 交互式通信
  - Roo Code 工具
  - 澄清
  - 用户反馈
image: /img/social-share.jpg
---

# 提出后续问题

`ask_followup_question` 工具通过提出具体问题来实现交互式通信，以收集完成任务所需的信息。

---

## 参数

该工具接受以下参数：

- `question`（必需）：向用户提出的具体问题
- `follow_up`（可选）：一个包含 2-4 个建议答案的列表，用于指导用户响应，每个答案都包含在 `<suggest>` 标签中

---

## 功能

该工具在 Roo 和用户之间创建一个对话界面，用于在遇到歧义或决策点时收集澄清信息、额外细节或用户偏好。每个问题都可以包含建议的响应，以简化交互。

---

## 使用场景

- 当原始请求中缺少关键信息时
- 当 Roo 需要在多种有效的实现方法中进行选择时
- 当需要技术细节或偏好来继续进行时
- 当 Roo 遇到需要解决的歧义时
- 当额外的上下文会显著提高解决方案质量时

---

## 主要特性

- 提供了一种结构化的方式来收集特定信息，而不会中断工作流程
- 包含建议的答案，以减少用户输入并指导响应
- 跨交互维护对话历史和上下文
- 支持包含图像和代码片段的响应
- 作为“始终可用”工具集的一部分，在所有模式下都可用
- 启用对实现决策的直接用户指导
- 使用 `<answer>` 标签格式化响应，以将其与常规对话区分开来
- 成功使用时重置连续错误计数器

---

## 限制

- 限制为每次工具使用只问一个具体问题
- 在 UI 中将建议作为可选项呈现
- 无法强制结构化响应——用户仍可以自由响应
- 过度使用会减慢任务完成速度并造成碎片化体验
- 建议的答案必须完整，不能包含需要用户编辑的占位符
- 对用户响应没有内置验证
- 不包含强制特定答案格式的机制

---

## 工作原理

当调用 `ask_followup_question` 工具时，它遵循以下过程：

1. **参数验证**：验证必需的 `question` 参数并检查可选建议
   - 确保提供了问题文本
   - 使用 `fast-xml-parser` 库从 `follow_up` 参数解析任何建议的答案
   - 将建议规范化为数组格式，即使只有一个建议

2. **JSON 转换**：将 XML 结构转换为标准化的 JSON 格式以供 UI 显示
   ```typescript
   {
     question: "用户的问题在这里",
     suggest: [
       { answer: "建议 1" },
       { answer: "建议 2" }
     ]
   }
   ```

3. **UI 集成**：
   - 通过 `ask("followup", ...)` 方法将 JSON 结构传递给 UI 层
   - 在界面中向用户显示可选择的建议按钮
   - 为选择或输入响应创建交互式体验

4. **响应收集和处理**：
   - 捕获用户文本输入和响应中包含的任何图像
   - 在返回给助手时用 `<answer>` 标签包装用户响应
   - 保留用户响应中包含的任何图像
   - 通过将响应添加到历史记录中来维护对话上下文
   - 成功使用时重置连续错误计数器

5. **错误处理**：
   - 使用计数器跟踪连续错误
   - 成功使用时重置计数器
   - 提供特定的错误消息：
     - 对于缺少参数："Missing required parameter 'question'"
     - 对于 XML 解析："Failed to parse operations: [error message]"
     - 对于无效格式："Invalid operations xml format"
   - 包含防止在缺少必需参数时执行工具的保障措施
   - 发生错误时增加连续错误计数

---

## 工作流程

问答周期遵循以下顺序：

1. **识别信息差距**：Roo 识别继续进行所需的信息
2. **创建具体问题**：Roo 制定一个清晰、有针对性的问题
3. **开发建议**：Roo 创建相关的建议答案（可选但推荐）
4. **调用工具**：助手使用问题和可选建议调用工具
5. **UI 呈现**：问题和建议作为交互元素显示给用户
6. **用户响应**：用户选择建议或提供自定义答案
7. **消息处理**：系统处理部分和完整消息
   - 对于流式响应，处理到达的数据块
   - 对于完整消息，一次性处理整个响应
   - 无论消息分块如何，都保持状态一致性
8. **响应处理**：系统用 `<answer>` 标签包装响应并保留图像
9. **上下文集成**：响应被添加到对话历史中
10. **任务继续**：Roo 使用新信息继续任务

---

## 使用示例

- 在开发 Web 应用程序时，Roo 可能会询问首选的样式框架（Bootstrap、Tailwind、自定义 CSS）
- 在创建 API 时，Roo 可能会询问身份验证方法（JWT、OAuth、API 密钥）
- 在重构代码时，Roo 可能会询问优先考虑性能还是可读性
- 在设置数据库时，Roo 可能会询问特定的模式设计偏好
- 在创建自定义功能时，Roo 可能会询问特定的行为期望
- 在排除错误时，Roo 可能会询问特定的环境详细信息

---

## 响应格式

当用户响应问题时，响应会用 `<answer>` 标签格式化以确保清晰和一致。这种格式有助于清楚地区分用户的答案和其他对话元素。

示例响应格式：
```
<answer>
使用 Tailwind CSS 进行实用优先的样式设计，具有最大的灵活性
</answer>
```

响应格式的关键特征：
- 用 `<answer>` 标签包围
- 保留原始响应的格式
- 如果响应中包含图像，则保留图像
- 返回完整文本，即使对于长响应也是如此

---

## 使用示例

询问实现偏好：
```
<ask_followup_question>
<question>您希望为此 Web 应用程序采用哪种样式方法？</question>
<follow_up>
<suggest>使用 Bootstrap 进行快速开发，具有统一的组件</suggest>
<suggest>使用 Tailwind CSS 进行实用优先的样式设计，具有最大的灵活性</suggest>
<suggest>使用原生 CSS 和自定义样式，实现完全控制和最小依赖</suggest>
</follow_up>
</ask_followup_question>
```

请求技术澄清：
```
<ask_followup_question>
<question>此应用程序应使用什么数据库来存储用户数据？</question>
<follow_up>
<suggest>MongoDB 用于灵活的模式和基于文档的存储</suggest>
<suggest>PostgreSQL 用于具有强一致性保证的关系数据</suggest>
<suggest>Firebase 用于实时更新和简化的后端管理</suggest>
<suggest>SQLite 用于无需外部依赖的轻量级本地存储</suggest>
</follow_up>
</ask_followup_question>
```

解决需求中的歧义：
```
<ask_followup_question>
<question>应用程序应如何处理用户身份验证？</question>
<follow_up>
<suggest>实现电子邮件/密码身份验证和账户验证</suggest>
<suggest>使用社交登录提供商（Google、GitHub 等）进行快速注册</suggest>
<suggest>实现电子邮件/密码和社交登录选项</suggest>
</follow_up>
</ask_followup_question>
```
