---
描述: 了解 attempt_completion 工具如何在 Roo Code 中标记任务完成、呈现结果并支持迭代优化。
关键词:
  - attempt_completion
  - 任务完成
  - 结果展示
  - Roo Code 工具
  - 用户反馈
  - 任务摘要
image: /img/social-share.jpg
---

# 尝试完成

`attempt_completion` 工具用于标记 Roo 认为任务已完成，并向用户呈现结果。它提供已完成内容的摘要，可选择性地包含一个命令来演示结果，并通过用户反馈支持持续优化。

---

## 参数

该工具接受以下参数：

- `result`（必需）：最终结果描述，总结已完成的内容
- `command`（可选）：要执行的 CLI 命令，用于演示结果

---

## 功能

该工具通过呈现已完成内容的最终摘要来标记任务的结束。它向用户和系统发出信号，表明当前任务已完成。如果提供了命令，它还可以通过实时执行来演示结果。

---

## 使用场景

- 当 Roo 认为用户的任务已完成时
- 当总结所做的更改或改进时
- 当通过命令执行演示当前结果时
- 当为用户提供解决方案的检查点以收集反馈时
- 当从一个工作阶段过渡到潜在的优化阶段时

---

## 主要特性

- 清晰地表明 Roo 认为任务已完成
- 以简洁的消息总结成就
- 可选择性地通过命令执行演示结果
- 启用用户反馈以进行进一步优化
- 以与常规消息不同的特殊 UI 格式显示结果
- 捕获任务完成遥测数据以进行系统分析
- 通过提供检查点来维护结构化的对话流程
- 支持大型工作流中的子任务完成
- 确保用户收到清晰的已完成内容摘要
- 作为“始终可用”工具组的一部分，在所有模式下都可用

---

## 限制

- 在确认先前的工具使用成功之前不应使用（指南，非强制）
- 仅限于单个命令来演示结果
- 无法呈现多个命令选项
- 命令执行前需要用户批准
- 仅限于通过 CLI 命令展示的结果
- 不能用于部分任务完成或进度更新
- 结果格式化会通过内部处理去除 XML 结束标签

---

## 工作原理

当调用 `attempt_completion` 工具时，它遵循以下过程：

1. **安全考虑**（指南，非强制）：
   - 指示 AI 确认先前的工具使用已成功
   - 这是一个最佳实践，而不是程序强制执行的机制

2. **结果展示**：
   - 以特殊的“completion_result”UI 格式向用户显示完成消息
   - 使用 `removeClosingTag` 函数从结果文本中删除 XML 结束标签
   - 以与常规消息不同的方式呈现结果，以实现视觉区分

3. **命令执行**（如果提供）：
   - 在执行命令前请求用户批准
   - 仅在用户批准后执行
   - 使用系统的命令执行功能执行命令
   - 向用户显示命令的结果

4. **反馈收集**：
   - 等待用户对完成结果的反馈
   - 处理此反馈并将其返回给 AI
   - 根据用户输入启用持续优化

5. **任务完成和继续**：
   - 在系统中标记任务已完成
   - 捕获已完成任务的遥测数据
   - 对于子任务，提供完成子任务并恢复父任务的选项
   - 通过反馈机制支持持续对话

6. **实现集成**：
   - 工具结果通过 `parse-assistant-message.ts` 中的系统解析机制进行解析
   - 该工具是“ALWAYS_AVAILABLE_TOOLS”常量的一部分，使其在所有模式下都可用

---

## 结果格式化指南

结果消息应遵循以下指南：

- 清晰地传达已完成的内容
- 简洁但完整
- 专注于为用户提供的价值
- 避免不必要的客套话或填充文本
- 保持专业、直接的语调
- 以易于扫描和理解的方式呈现信息
- 承认用户可能会提供反馈以进行进一步优化

注意：系统会通过 `removeClosingTag` 函数自动从结果文本中去除 XML 结束标签。

---

## 命令选择指南

包含命令时，请遵循以下指南：

- 选择能直观演示结果的命令
- 优先选择能向用户展示创建或修改内容的命令
- 示例包括：
  * `open index.html` 以显示创建的网站
  * `npm start` 以启动开发服务器
  * `python app.py` 以运行创建的应用程序
- 避免仅打印文本的命令（如 `echo` 或 `cat`）
- 请记住，命令执行前需要用户批准
- 确保命令对用户的操作系统有效

---

## 反馈和 UI 表示

`attempt_completion` 工具具有独特的反馈机制：

- 结果以与常规消息不同的特殊“completion_result”UI 格式出现
- 系统在呈现结果后等待用户反馈
- 反馈被处理并返回给 Roo 以进行进一步优化
- 这创造了一个迭代改进循环，而不是结束对话
- UI 包含用于提供反馈的特殊元素
- 结果作为对话流程中的清晰检查点

在子任务中使用时：
- 系统提供完成子任务并恢复父任务的选项
- 如果获得批准，子任务将附带摘要完成
- 父任务在完成的子任务上下文中恢复
- 这使得复杂的嵌套工作流能够保持上下文

---

## 使用示例

- 创建网站时，Roo 呈现解决方案并使用 `open index.html` 显示结果。用户提供反馈，Roo 优化设计。
- 实现功能时，Roo 总结更改及其影响。用户请求额外的测试覆盖，Roo 继续任务。
- 修复错误时，Roo 解释修复的内容以及解决方案如何解决根本原因。用户确认修复有效。
- 设置开发环境时，Roo 确认所有组件都已安装。用户请求额外配置，Roo 继续。
- 创建数据处理脚本时，Roo 总结功能。用户建议性能改进，Roo 优化代码。

---

## 使用示例

仅包含结果摘要的任务完成：
```
<attempt_completion>
<result>
我已经更新了导航栏的 CSS 以匹配设计模型。更改包括：
1. 更新配色方案以使用新的品牌颜色
2. 为移动设备添加了响应式行为
3. 修复了下拉菜单中的对齐问题
</result>
</attempt_completion>
```

包含结果和演示命令的任务完成：
```
<attempt_completion>
<result>
我创建了一个简单的 React 应用程序，具有以下功能：
1. 带有请求的英雄部分的响应式登录页面
2. 带有验证的工作联系表单
3. 在所有三个请求页面之间的导航
4. 与提供的设计模型匹配的样式
</result>
<command>npm start</command>
</attempt_completion>
```

执行 Python 脚本任务的完成：
```
<attempt_completion>
<result>
我创建了一个数据处理脚本，该脚本：
1. 从数据目录读取 CSV 文件
2. 根据请求清理和规范化数据
3. 以 JSON 格式生成摘要统计信息
4. 将处理后的数据输出到输出目录
</result>
<command>python process_data.py</command>
</attempt_completion>
```
