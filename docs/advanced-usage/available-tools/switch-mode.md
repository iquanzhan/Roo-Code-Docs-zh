---
description: 了解 switch_mode 如何实现 Roo Code 中 Code、Architect、Ask 和 Debug 模式之间的无缝切换，以进行专门的任务处理。
keywords:
  - switch_mode
  - Roo Code 工具
  - 模式切换
  - 操作模式
  - Code 模式
  - Architect 模式
  - Debug 模式
  - Ask 模式
  - 任务转换
  - VS Code AI
image: /img/social-share.jpg
---

# 切换模式

`switch_mode` 工具使 Roo 能够在不同的操作模式之间切换，每种模式都具有针对特定类型任务的专业能力。当当前任务需要不同的专业知识时，这允许在 Code、Architect、Ask 或 Debug 等模式之间无缝切换。

---

## 参数

该工具接受以下参数：

- `mode_slug`（必需）：要切换到的模式的 slug（例如，“code”、“ask”、“architect”）
- `reason`（可选）：切换模式的原因，为用户提供上下文

---

## 功能

当当前任务由另一种模式的功能更好地处理时，此工具会请求模式更改。它在转移 Roo 的关注点和可用工具集以匹配新任务阶段的要求时保持上下文。

---

## 使用场景

- 当从信息收集过渡到代码实现时
- 当从编码转向架构或设计时
- 当当前任务需要仅在不同模式中可用的功能时
- 当复杂项目的特定阶段需要专门的专业知识时

---

## 主要特性

- 在模式转换期间保持上下文连续性
- 为模式切换建议提供清晰的理由
- 所有模式更改都需要用户批准
- 强制执行每个模式特定的工具组限制
- 根据所选模式无缝调整工具可用性
- 适用于标准模式和自定义模式
- 在 UI 中显示模式切换和理由
- 使用 XML 样式的格式进行参数指定
- 处理特定于某些模式的文件类型限制

---

## 限制

- 无法切换到系统中不存在的模式
- 每次模式转换都需要明确的用户批准
- 在切换完成之前无法使用特定于模式的工具
- 模式切换后应用 500 毫秒的延迟，以允许更改生效
- 某些模式具有文件类型限制（例如，Architect 模式只能编辑 markdown 文件）
- 模式保留以供恢复仅适用于 `new_task` 功能，而不适用于一般模式切换

---

## 工作原理

当调用 `switch_mode` 工具时，它会遵循以下过程：

1. **请求验证**：
   - 验证系统中是否存在请求的模式
   - 检查是否提供了有效的 `mode_slug` 参数
   - 验证用户尚未处于请求的模式中
   - 确保 `reason` 参数（如果提供）格式正确

2. **模式转换准备**：
   - 将模式更改请求与提供的理由打包
   - 将更改请求呈现给用户以供批准

3. **模式激活（经用户批准后）**：
   - 更新 UI 以反映新模式
   - 根据模式的工具组配置调整可用工具
   - 应用模式特定的提示和行为
   - 应用 500 毫秒的延迟，以允许更改在执行下一个工具之前生效
   - 强制执行模式特定的任何文件限制

4. **继续**：
   - 使用新模式的功能继续任务
   - 保留与先前交互相关的上下文

---

## 工具组关联

`switch_mode` 工具属于“modes”工具组，但也包含在“always available”工具列表中。这意味着：

- 它可以在任何模式下使用，而不管模式配置的工具组如何
- 它可与其他核心工具（如 `ask_followup_question` 和 `attempt_completion`）一起使用
- 当任务要求发生变化时，它允许在工作流程的任何时候进行模式转换

---

## 模式结构

系统中的每个模式都有一个特定的结构：

- `slug`：模式的唯一标识符（例如，“code”、“ask”）
- `name`：模式的显示名称（例如，“Code”、“Ask”）
- `roleDefinition`：模式的专业角色和功能
- `customInstructions`：可选的模式特定指令，用于指导行为
- `groups`：可供模式使用的工具组，可选择限制

---

## 模式功能

核心模式提供以下专业功能：

- **Code 模式**：专注于编码任务，可以完全访问代码编辑工具
- **Architect 模式**：专门用于系统设计和架构规划，仅限于编辑 markdown 文件
- **Ask 模式**：针对回答问题和提供信息进行了优化
- **Debug 模式**：配备了用于系统问题诊断和解决的功能

---

## 自定义模式

除了核心模式之外，系统还支持自定义的项目特定模式：

- 可以定义自定义模式，并启用特定的工具组
- 它们可以指定自定义角色定义和指令
- 系统首先检查自定义模式，然后回退到核心模式
- 自定义模式定义优先于具有相同 slug 的核心模式

---

## 文件限制

不同的模式可能有特定的文件类型限制：

- **Architect 模式**：只能编辑与 `.md` 扩展名匹配的文件
- 尝试编辑受限制的文件类型会导致 `FileRestrictionError`
- 这些限制有助于在模式之间强制执行适当的关注点分离

---

## 使用示例

- 在讨论新功能时，Roo 从 Ask 模式切换到 Architect 模式以帮助设计系统结构。
- 在 Architect 模式下完成架构规划后，Roo 切换到 Code 模式以实现设计的功能。
- 在开发过程中遇到错误时，Roo 从 Code 模式切换到 Debug 模式以进行系统故障排除。

---

## 使用示例

切换到 Code 模式进行实现：
```
<switch_mode>
<mode_slug>code</mode_slug>
<reason>需要根据我们讨论的架构实现登录功能</reason>
</switch_mode>
```

切换到 Architect 模式进行设计：
```
<switch_mode>
<mode_slug>architect</mode_slug>
<reason>需要在实现之前设计系统架构</reason>
</switch_mode>
```

切换到 Debug 模式进行故障排除：
```
<switch_mode>
<mode_slug>debug</mode_slug>
<reason>需要系统地诊断身份验证错误</reason>
</switch_mode>
```

切换到 Ask 模式以获取信息：
```
<switch_mode>
<mode_slug>ask</mode_slug>
<reason>需要回答有关已实现功能的问题</reason>
</switch_mode>
```
