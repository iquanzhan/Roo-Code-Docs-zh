---
description: 学习如何在Roo Code中创建自定义模式，为特定任务定制AI行为。配置工具访问、文件权限和专业指令。
keywords:
  - 自定义模式
  - Roo Code定制
  - AI助手配置
  - 模式创建
  - 工具权限
  - 文件限制
image: /img/social-share.jpg
---

# 自定义模式

Roo Code允许您创建**自定义模式**来根据特定任务或工作流程定制Roo的行为。自定义模式可以是**全局的**（在所有项目中可用）或**项目特定的**（在单个项目中定义）。

<div style={{ position: 'relative', paddingBottom: '56.25%', height: 0, overflow: 'hidden' }}>
  <iframe
    src="https://www.youtube.com/embed/qgqceCuhlRA"
    style={{
      position: 'absolute',
      top: 0,
      left: 0,
      width: '100%',
      height: '100%',
    }}
    frameBorder="0"
    allow="autoplay; encrypted-media"
    allowFullScreen
    title="自定义模式概述视频"
  ></iframe>
</div>

<br />

:::tip 粘性模型实现高效工作流程
每个模式（包括自定义模式）都具有**粘性模型**功能。这意味着Roo Code会自动记住并为特定模式选择您上次使用的模型。这使您可以为不同任务分配不同的首选模型，无需不断重新配置，因为Roo在切换模式时会自动切换模型。
:::

:::info 发现社区模式
寻找现成的自定义模式？访问[Roo Code市场](/features/marketplace)，一键浏览和安装社区贡献的模式。市场提供各种任务的专业模式，如React开发、文档编写、测试等，全部由Roo Code社区创建和分享。
:::

---

## 为什么要使用自定义模式？

*   **专业化：** 创建针对特定任务优化的模式，如"文档编写者"、"测试工程师"或"重构专家"。
*   **安全性：** 限制模式对敏感文件或命令的访问。例如，"审查模式"可以限制为只读操作。
*   **实验：** 安全地试验不同的提示和配置，而不会影响其他模式。
*   **团队协作：** 与团队共享自定义模式以标准化工作流程。

<img src="/img/custom-modes/custom-modes-3.png" alt="自定义模式界面概述" width="500" />

    *Roo Code创建和管理自定义模式的界面。*

---

## 自定义模式包含什么？

自定义模式由几个关键属性定义。理解这些概念将帮助您有效地定制Roo的行为。

| UI字段/YAML属性                 | 概念描述                                                                                                                                                                                                                                                                                                                                                       |
| ---------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Slug (`slug`)                            | 模式的**唯一内部标识符**。Roo Code使用它来引用模式，特别是用于关联[模式特定指令文件](#通过文件目录进行模式特定指令)。                                                                                                                                                                                                   |
| 名称 (`name`)                            | 模式在Roo Code用户界面中显示的**显示名称**。这应该是人类可读且具有描述性的。                                                                                                                                                                               |
| 描述 (`description`)              | 在模式选择器UI中显示的模式的**简短、用户友好摘要**。<br />- 此文本出现在重新设计的模式选择器中模式名称下方，为用户提供模式功能的快速理解。<br />- 保持简洁，专注于模式为用户做什么。                                                                                              |
| 角色定义 (`roleDefinition`)       | 定义模式的**核心身份和专业知识**。此文本放置在系统提示的开头。<br />- 其主要功能是定义Roo在此模式激活时的个性和行为。<br />- 随着`description`字段的引入，`roleDefinition`应提供模式身份的详细描述，而`description`字段处理UI的简短摘要。<br />- `whenToUse`属性现在在自动化上下文中优先用于摘要，如任务编排。 |
| 可用工具 (`groups`)               | 定义模式的**允许工具集和文件访问权限**。<br />- 在UI中，这对应于选择模式可以使用哪些通用工具类别（如读取文件、编辑文件、浏览或执行命令）。<br />- UI在每个模式下方的"允许文件"部分显示可以编辑哪些文件。<br />- "编辑"组的文件类型限制通常通过手动YAML/JSON配置或要求Roo设置它们来管理，如[属性详情](#groups)中所详述。 |
| 何时使用（可选） (`whenToUse`)     | （可选）为Roo的自动化决策提供指导，特别是模式选择和任务编排。<br />- 此文本由Roo使用，特别是[`🪃 Orchestrator`](/basic-usage/using-modes#orchestrator-mode-aka-boomerang-mode)模式，用于[编排任务](/features/boomerang-tasks)（例如，通过[`new_task`](/advanced-usage/available-tools/new-task)工具）。<br />- 它还帮助Roo决定何时[切换模式](/basic-usage/using-modes#switching-between-modes)（例如，通过[`switch_mode`](/advanced-usage/available-tools/switch-mode)工具）。<br />- 此字段**不显示在模式选择器UI中** - 这由`description`字段处理。 |
| 自定义指令（可选） (`customInstructions`) | 模式的**特定行为指南**或规则。<br />- 这些指令添加到系统提示的末尾附近，以进一步细化`roleDefinition`之外的Roo行为。<br />- 可以直接在配置中提供或通过单独的指令文件提供。                                                                                               |

---
## 导入/导出模式

轻松共享、备份和模板化您的自定义模式。此功能允许您将任何模式及其关联规则导出到单个便携式YAML文件中，您可以将其导入到任何项目中。

### 主要功能
- **可共享设置：** 将模式和其规则打包到一个文件中，便于与团队共享。
- **轻松备份：** 保存您的自定义模式配置，永不错过。
- **项目模板：** 为不同类型的项目创建标准化的模式模板。
- **简单迁移：** 在全局设置和特定项目之间轻松移动模式。
- **灵活的Slug更改：** 在导出的文件中更改模式slugs，无需手动路径编辑。

---

### 使用案例

**之前：** 手动重新创建自定义模式并为每个新项目或团队成员复制`.roo/rules-{slug}/`文件夹。更改slugs需要在YAML文件中手动更新路径。

**使用此功能：** 单击一次将模式及其所有规则导出到YAML文件。再单击一次导入它，自动设置所有内容。您现在可以在导出的文件中更改slug，导入过程会自动处理所有路径更新。

### 工作原理

导入/导出功能从**模式**视图管理。

![模式导出和导入按钮](/img/custom-modes/custom-modes-5.png)

#### 导出模式
1.  导航到**模式**视图。
2.  选择要导出的模式。
3.  单击**导出模式**按钮（下载图标）。
4.  选择位置保存`.yaml`文件。

Roo将模式的配置和项目中`.roo/rules-{slug}/`目录中找到的任何规则打包到YAML文件中。

#### 导入模式
1.  在**模式**视图中单击**导入模式**按钮（上传图标）。
2.  选择模式的YAML文件。
3.  在出现的对话框中选择导入级别：
    ![导入级别对话框](/img/custom-modes/custom-modes-6.png)
    -   **项目：** 模式仅在当前工作区中可用。它添加到`.roomodes`文件中，其规则保存在项目内的`.roo/rules-{slug}/`目录中。
    -   **全局：** 模式在所有项目中可用。它添加到您的全局设置中，规则存储在系统的全局Roo配置目录中（例如，`~/.roo/rules-{slug}/`）。

**注意：** 导出带规则的模式时，所有文件路径都标准化为使用正斜杠以实现跨平台兼容性。这确保模式可以在使用不同操作系统的团队成员之间共享。

---

### 导出的YAML文件格式：

```yaml
customModes:
  - slug: "my-custom-mode"
    name: "My Custom Mode"
    roleDefinition: "You are a helpful assistant."
    groups: ["read", "edit"]
    rulesFiles:
      - relativePath: "rules-my-custom-mode/rules.md"
        content: "These are the rules for my custom mode."
```

### 导入时更改Slugs

导入模式时，您可以在导入前在导出的YAML文件中更改slug：

1. **导出模式**，slug为`original-mode`
2. **编辑YAML文件**并将slug更改为`new-mode`
3. **导入文件** - 导入过程将：
   - 使用更新的slug创建新模式
   - 更新规则文件路径以匹配新slug

注意：导入期间的自动slug更改处理确保当您更改导出文件中的模式slug时，规则文件路径正确更新。

---

### 常见问题

**"如果我导入具有相同'slug'的现有模式会怎样？"**
- 现有模式将被导入文件中的配置覆盖。

**"全局和项目导入之间的主要区别是什么？"**
- **全局**模式在所有VS Code项目中可用。**项目**模式特定于导入它们的工作区，并存储在项目根目录的`.roomodes`文件中。

**"我可以导出内置模式如Code或Architect吗？"**
- 可以。如果您自定义了内置模式（例如，更改其指令），您可以导出它以保存您的自定义。

**"如果我导入带规则的全局级别模式会怎样？"**
- 规则仍然保留。它们存储在用户主目录中的全局`rules-{slug}`文件夹中（例如，`~/.roo/rules-my-custom-mode/`），而不是项目特定的`.roo`文件夹。

**"slug更改功能如何工作？"**
- 当您在导入前在导出的YAML文件中更改slug时，导入过程更新规则文件路径以匹配新slug。这确保模式与其新身份正确工作。

---

## 创建和配置自定义模式的方法

您可以通过几种方式创建和配置自定义模式：

### 1. 询问Roo！（推荐）

您可以通过要求Roo Code为您快速创建基本自定义模式。例如：
```
创建一个名为"文档编写者"的新模式。它应该只能读取文件和编写Markdown文件。
```
Roo Code将指导您完成该过程，提示[自定义模式包含什么？](#自定义模式包含什么)表中描述的属性所需信息。Roo将使用首选YAML格式创建模式。稍后要进行微调或进行特定调整，您可以使用提示选项卡或手动配置。

### 2. 使用提示选项卡

1.  **打开提示选项卡：** 单击Roo Code顶部菜单栏中的<Codicon name="notebook" />图标。
2.  **创建新模式：** 单击模式标题右侧的<Codicon name="add" />按钮。
3.  **填写字段：**

<img src="/img/custom-modes/custom-modes-4.png" alt="提示选项卡中的自定义模式创建界面" width="600" />

    *显示名称、slug、描述、保存位置、角色定义、可用工具、自定义指令字段的自定义模式创建界面。*

    该界面为`Name`、`Slug`、`Description`、`Save Location`、`Role Definition`、`When to Use (optional)`、`Available Tools`和`Custom Instructions`提供字段。填写这些后，单击"Create Mode"按钮。Roo Code将以YAML格式保存新模式。

*有关每个属性的概念解释，请参阅[自定义模式包含什么？](#自定义模式包含什么)表。可以通过要求Roo或通过手动YAML/JSON配置添加"编辑"工具组的文件类型限制。*

### 3. 手动配置（YAML和JSON）

您可以直接编辑配置文件来创建或修改自定义模式。此方法提供对所有属性的最大控制。Roo Code现在支持YAML（首选）和JSON格式。

*   **全局模式：** 编辑`custom_modes.yaml`（首选）或`custom_modes.json`文件。通过**提示选项卡** > <Codicon name="settings-gear" />（"Global Prompts"旁边的设置菜单图标）> "Edit Global Modes"访问它。
*   **项目模式：** 在项目根目录中编辑`.roomodes`文件（可以是YAML或JSON）。通过**提示选项卡** > <Codicon name="settings-gear" />（"Project Prompts"旁边的设置菜单图标）> "Edit Project Modes"访问它。

这些文件定义了自定义模式的数组/列表。

**YAML示例（`custom_modes.yaml`或`.roomodes`）：**
```yaml
customModes:
  - slug: docs-writer
    name: 📝 文档编写者
    description: 专门用于编写和编辑技术文档的模式。
    roleDefinition: 您是一位专门编写清晰文档的技术作家。
    whenToUse: 使用此模式编写和编辑文档。
    customInstructions: 在文档中注重清晰性和完整性。
    groups:
      - read
      - - edit  # 元组的第一个元素
        - fileRegex: \.(md|mdx)$  # 第二个元素是选项对象
          description: 仅限Markdown文件
      - browser
  - slug: another-mode
    name: 另一个模式
    # ... 其他属性
```

**JSON替代格式（`custom_modes.json`或`.roomodes`）：**
```json
{
  "customModes": [
    {
      "slug": "docs-writer",
      "name": "📝 文档编写者",
      "description": "专门用于编写和编辑技术文档的模式。",
      "roleDefinition": "您是一位专门编写清晰文档的技术作家。",
      "whenToUse": "使用此模式编写和编辑文档。",
      "customInstructions": "在文档中注重清晰性和完整性。",
      "groups": [
        "read",
        ["edit", { "fileRegex": "\\.(md|mdx)$", "description": "仅限Markdown文件" }],
        "browser"
      ],
      {
        "slug": "another-mode",
        "name": "另一个模式"
      }
    }
  ]
}
```

### YAML/JSON属性详情

##### `slug`
*   **目的：** 模式的唯一标识符。
*   **格式：** 必须匹配模式`/^[a-zA-Z0-9-]+$/`（仅限字母、数字和连字符）。
*   **用途：** 在内部使用，并在文件/目录名中用于模式特定规则（例如，`.roo/rules-{slug}/`）。
*   **建议：** 保持简短且具有描述性。
*   **注意：** `source`属性由系统自动添加，不应手动设置。
*   *YAML示例：* `slug: docs-writer`
*   *JSON示例：* `"slug": "docs-writer"`

##### `name`
*   **目的：** 在Roo Code UI中显示的名称。
*   **格式：** 可以包含空格和适当的大小写。
*   *YAML示例：* `name: 📝 文档编写者`
*   *JSON示例：* `"name": "文档编写者"`

##### `description`
*   **目的：** 在模式选择器UI中显示在模式名称下方的简短、用户友好的摘要。
*   **格式：** 保持简洁，专注于模式为用户做什么。
*   **UI显示：** 此文本显示在重新设计的模式选择器中，为用户提供模式功能的快速理解。
*   *YAML示例：* `description: 专门用于编写和编辑技术文档的模式。`
*   *JSON示例：* `"description": "专门用于编写和编辑技术文档的模式。"`

##### `roleDefinition`
*   **目的：** 模式角色、专业知识和个性的详细描述。
*   **位置：** 当模式处于活动状态时，此文本放置在系统提示的开头。
*   **更新的角色：** 随着`description`字段的引入，`roleDefinition`应该提供模式身份的详细描述，而`description`字段处理UI的简短摘要。`whenToUse`属性现在在自动化上下文中优先用于摘要。
*   *YAML示例（多行）：*
     ```yaml
     roleDefinition: >-
       您是一位测试工程师，专长于：
       - 编写全面的测试套件
       - 测试驱动开发
     ```
*   *JSON示例：* `"roleDefinition": "您是一位专门编写清晰文档的技术作家。"`

##### `groups`
*   **目的：** 数组/列表定义模式可以访问的工具组以及任何文件限制。
*   **可用工具组（字符串）：** `"read"`、`"edit"`、`"browser"`、`"command"`、`"mcp"`。
*   **结构：** `groups`属性使用特定结构：
    *   简单字符串用于无限制访问：`"edit"`
    *   元组（二元素数组）用于受限访问：`["edit", { fileRegex: "pattern", description: "optional" }]`
*   **"edit"组的文件限制：**
    *   要应用文件限制，"edit"条目变为元组（YAML列表或JSON数组），其中第一个元素是`"edit"`，第二个是定义限制的映射/对象。
    *   `fileRegex`：用于控制模式可以编辑哪些文件的正则表达式字符串。
        *   在YAML中，通常对正则表达式特殊字符使用单反斜杠（例如，`\.md$`）。
        *   在JSON中，反斜杠必须双转义（例如，`\\.md$`）。
    *   `description`：描述限制的可选字符串。
    *   有关更复杂的模式，请参见[理解自定义模式中的正则表达式](#理解自定义模式中的正则表达式)。
*   *YAML示例：*
    ```yaml
    groups:
      - read
      - - edit  # 元组的第一个元素
        - fileRegex: \.(js|ts)$  # 第二个元素是选项对象
          description: 仅限JS/TS文件
      - command
    ```
*   *JSON示例：*
    ```json
    "groups": [
      "read",
      ["edit", { "fileRegex": "\\.(js|ts)$", "description": "仅限JS/TS文件" }],
      "command"
    ]
    ```

##### `whenToUse`
*   **目的：**（可选）为Roo的自动化决策提供指导，特别是模式选择和任务编排。
*   **格式：** 描述此模式的理想场景或任务类型的字符串。
*   **用途：** Roo使用此字段进行自动化决策，**不显示在模式选择器UI中** - 这由`description`字段处理。如果填充，Roo在编排和模式切换中使用此描述；否则，使用`roleDefinition`的第一句话。
*   *YAML示例：* `whenToUse: 此模式最适合重构Python代码。`
*   *JSON示例：* `"whenToUse": "此模式最适合重构Python代码。"`

##### `customInstructions`
*   **目的：** 包含模式附加行为指南的字符串。
*   **位置：** 此文本添加在系统提示的末尾附近。
*   **补充：** 可以通过[通过文件/目录进行模式特定指令](#通过文件目录进行模式特定指令)进行补充。
*   *YAML示例（多行）：*
    ```yaml
    customInstructions: |-
      编写测试时：
      - 使用describe/it块
      - 包含有意义的描述
    ```
*   *JSON示例：* `"customInstructions": "专注于解释概念并提供示例。"`

### YAML格式的优势

YAML现在是定义自定义模式的首选格式，因为它比JSON具有以下优势：

*   **可读性：** YAML基于缩进的结构通常更容易让人类阅读和理解复杂配置。
*   **注释：** YAML允许注释（以`#`开头的行），可以注释模式定义。
    ```yaml
    customModes:
      - slug: security-review
        name: 🔒 安全审查员
        # 此模式限制为只读访问
        roleDefinition: 您是一位安全专家，负责审查代码中的漏洞。
        whenToUse: 用于安全审查和漏洞评估。
        # 只允许读取文件，无编辑权限
        groups:
          - read
          - browser
    ```
*   **多行字符串：** YAML为多行字符串（例如，`roleDefinition`或`customInstructions`）提供了更清晰的语法，使用`|`（文字块）或`>`（折叠块）。
    ```yaml
    customModes:
      - slug: test-engineer
        name: 🧪 测试工程师
        roleDefinition: >-
          您是一位测试工程师，专长于：
          - 编写全面的测试套件
          - 测试驱动开发
          - 集成测试
          - 性能测试
        customInstructions: |-
          编写测试时：
          - 使用describe/it块
          - 包含有意义的描述
          - 测试边界情况
          - 确保适当的覆盖率
        # ... 其他属性
    ```
*   **较少标点符号：** YAML通常比JSON需要更少的标点符号（如逗号和大括号），减少了语法错误。
*   **编辑器支持：** 大多数现代代码编辑器为YAML文件提供出色的语法高亮和验证，进一步增强了可读性并减少了错误。

虽然JSON仍然完全支持且不会被弃用，但通过UI创建的新模式或通过询问Roo创建的模式将默认为YAML。`.roomodes`文件和全局配置文件都可以是YAML或JSON格式。

#### 使用YAML的技巧

手动编辑YAML时，请记住以下几点：

*   **缩进是关键：** YAML使用缩进（空格，不是制表符）来定义结构。不正确的缩进是最常见的错误来源。确保嵌套元素的缩进一致。
*   **冒号用于键值对：** 键后面必须跟一个冒号和一个空格（例如，`slug: my-mode`）。
*   **连字符用于列表项：** 列表项以连字符和空格开头（例如，`- read`）。
*   **验证您的YAML：** 如果遇到问题，请使用在线YAML验证器或编辑器的内置验证来检查语法错误。

### 迁移到YAML格式

*   **全局模式：** 只有当Roo Code启动时，在以下条件下才会自动迁移`custom_modes.json`到`custom_modes.yaml`：
    1.  Roo Code启动。
    2.  `custom_modes.json`文件存在。
    3.  `custom_modes.yaml`文件尚不存在。
    迁移过程读取现有的JSON文件，将其转换为YAML格式，创建新的`custom_modes.yaml`文件，并保留原始JSON文件（例如，通过重命名）以备回滚。如果`custom_modes.yaml`已存在，则将使用它，并且不会自动迁移`custom_modes.json`。

*   **项目模式（`.roomodes`）：**
    *   **无自动启动迁移：** 与全局模式不同，项目特定的`.roomodes`文件在Roo Code启动时不会自动从JSON转换为YAML。需要手动转换现有的JSON `.roomodes`文件。
    *   **格式检测：** Roo Code可以读取`.roomodes`文件的YAML或JSON格式。Roo Code通过首先尝试将`.roomodes`文件解析为YAML来自动检测格式。
    *   **UI编辑时转换：** 如果您通过Roo Code UI（例如，通过提示选项卡）编辑项目特定模式，并且现有的`.roomodes`文件是JSON格式，Roo Code将以YAML格式保存更改。这有效地将文件转换为YAML。原始JSON内容将被YAML覆盖。
    *   **手动转换：** 如果您想在不进行UI编辑的情况下将现有的`.roomodes` JSON文件转换为YAML，您需要手动执行此操作。您可以：
        1.  打开您现有的JSON `.roomodes`文件。
        2.  将其内容转换为YAML（您可以要求Roo帮助完成此操作，或使用在线转换器）。
        3.  将`.roomodes`文件的内容替换为新的YAML内容，或将旧文件重命名（例如，`.roomodes.json.bak`）并将新内容保存到名为`.roomodes`的文件中。
        确保生成的YAML有效。

:::tip
对于`.roomodes`文件的手动转换，您可以使用在线JSON到YAML转换器或要求Roo帮助将特定模式配置从JSON重新格式化为YAML。保存前始终验证您的YAML。
:::
---

## 通过文件/目录进行模式特定指令

:::info 模式特定指令文件位置
您可以使用工作区中的专用文件或目录为自定义模式提供指令。与仅使用`customInstructions`属性相比，这允许更好地组织和版本控制。

**首选方法：目录（`.roo/rules-{mode-slug}/`）**
```
.
├── .roo/
│   └── rules-docs-writer/  # 示例模式slug "docs-writer"
│       ├── 01-style-guide.md
│       └── 02-formatting.txt
└── ... (其他项目文件)
```

**回退方法：单个文件（`.roorules-{mode-slug}`）**
```
.
├── .roorules-docs-writer  # 示例模式slug "docs-writer"
└── ... (其他项目文件)
```

**遗留回退：`.clinerules-{mode-slug}`**
为了向后兼容，系统还检查`.clinerules-{mode-slug}`文件作为额外的回退，尽管不建议在新项目中使用。

如果目录存在且包含文件，则目录方法优先。

**规则目录范围：**
- **全局模式：** 规则存储在`~/.roo/rules-{slug}/`（注意尾部斜杠）
- **项目模式：** 规则存储在`{workspace}/.roo/rules-{slug}/`（注意尾部斜杠）
:::

除了`customInstructions`属性外，您还可以通过工作区中的文件为模式特定指令提供。这对于：

*   将冗长或复杂的指令组织成多个可管理的文件。
*   使用版本控制轻松管理指令。
*   允许非技术团队成员在不编辑YAML/JSON的情况下修改指令。

Roo Code加载这些指令有两种方式，明确优先使用较新的基于目录的方法：

**1. 首选方法：基于目录的指令（`.roo/rules-{mode-slug}/`）**

*   **结构：** 在您的工作区根目录中创建一个名为`.roo/rules-{mode-slug}/`的目录。将`{mode-slug}`替换为您的模式slug（例如，`.roo/rules-docs-writer/`）。
*   **内容：** 将一个或多个包含指令的文件（例如，`.md`、`.txt`）放在该目录中。您可以使用子目录进一步组织指令。`.roo/rules-{mode-slug}/`目录中的文件被递归读取，并根据文件名（不区分大小写）按字母顺序追加。
*   **加载：** 在此目录结构中找到的所有指令文件都将被加载并应用于指定模式。系统文件（`.DS_Store`、`.swp`等）和缓存文件会自动排除。
*   **高级功能：** 系统支持带循环检测的符号链接以进行高级文件组织。

**2. 回退（向后兼容）：基于文件的指令（`.roorules-{mode-slug}`）**

*   **结构：** 如果`.roo/rules-{mode-slug}/`目录**不存在或为空**，Roo Code将在您的工作区根目录中查找名为`.roorules-{mode-slug}`的单个文件（例如，`.roorules-docs-writer`）。
*   **加载：** 如果找到，该单个文件的内容将作为模式的指令加载。

**优先级：**

*   **基于目录的方法（`.roo/rules-{mode-slug}/`）优先**。如果此目录存在且包含文件，则任何相应的根级`.roorules-{mode-slug}`文件将被**忽略**该模式。
*   这确保了迁移到新目录结构的项目行为可预测，而使用单文件方法的较旧项目保持兼容。

**与`customInstructions`结合：**

*   从文件系统加载的模式特定指令与模式配置中定义的`customInstructions`属性相结合。
*   通常，来自文件/目录的内容在来自`customInstructions`属性的内容之后追加。

---

## 配置优先级

模式配置按以下顺序应用：

1. 项目级模式配置（来自`.roomodes` - YAML或JSON）
2. 全局模式配置（来自`custom_modes.yaml`，然后如果找不到YAML则来自`custom_modes.json`）
3. 默认模式配置

**重要：** 当`.roomodes`和全局设置中存在相同slug的模式时，`.roomodes`版本完全覆盖全局版本。这适用于所有属性，而不仅仅是一些。例如，如果您在全局'code'模式和`.roomodes`中的项目特定'code'模式，当在该项目中工作时将使用项目版本，并且所有来自全局版本的属性都被忽略。

您可以通过在全局或项目特定配置中包含具有相同slug的模式来覆盖任何默认模式。

*   **关于指令文件的注意事项：** 在从文件系统加载模式特定指令时，目录`.roo/rules-{mode-slug}/`优先于在工作区根目录中找到的单个文件`.roorules-{mode-slug}`。

---

## 覆盖默认模式

您可以通过创建具有与默认模式相同slug的自定义模式来覆盖Roo Code的内置模式（如`💻 Code`、`🪲 Debug`、`❓ Ask`、`🏗️ Architect`、`🪃 Orchestrator`）。这通过创建具有相同slug的自定义模式来完成（例如，`code`、`debug`）。

### 全局覆盖模式

要跨所有项目自定义默认模式：

1. **打开提示选项卡：** 单击<Codicon name="notebook" />图标。
2. **访问设置菜单：** 单击"Global Prompts"旁边的<Codicon name="settings-gear" />图标。
3. **编辑全局模式：** 选择"Edit Global Modes"以编辑`custom_modes.yaml`（或`custom_modes.json`）。
4. **添加您的覆盖：**

**YAML示例：**
```yaml
customModes:
  - slug: code # 匹配默认'code'模式slug
    name: 💻 Code (全局覆盖) # 自定义显示名称
    roleDefinition: 您是一位具有全局特定约束的软件工程师。
    whenToUse: 此全局覆盖的代码模式用于JS/TS任务。
    customInstructions: 专注于项目特定的JS/TS开发。
    groups:
      - read
      - - edit
        - fileRegex: \.(js|ts)$
          description: 仅限JS/TS文件
```

**JSON替代：**
```json
{
  "customModes": [{
    "slug": "code",
    "name": "💻 Code (全局覆盖)",
    "roleDefinition": "您是一位具有全局特定约束的软件工程师",
    "whenToUse": "此全局覆盖的代码模式用于JS/TS任务。",
    "customInstructions": "专注于项目特定的JS/TS开发",
    "groups": [
      "read",
      ["edit", { "fileRegex": "\\.(js|ts)$", "description": "仅限JS/TS文件" }]
    ]
  }]
}
```
此示例将默认`💻 Code`模式替换为限制为JavaScript和TypeScript文件的版本。

### 项目特定模式覆盖

要仅为一个项目覆盖默认模式：

1. **打开提示选项卡：** 单击<Codicon name="notebook" />图标。
2. **访问设置菜单：** 单击"Project Prompts"旁边的<Codicon name="settings-gear" />图标。
3. **编辑项目模式：** 选择"Edit Project Modes"以编辑`.roomodes`文件（YAML或JSON）。
4. **添加您的覆盖：**

**YAML示例：**
```yaml
customModes:
  - slug: code # 匹配默认'code'模式slug
    name: 💻 Code (项目特定) # 自定义显示名称
    roleDefinition: 您是一位具有此项目特定约束的软件工程师。
    whenToUse: 此项目特定代码模式用于此项目中的Python任务。
    customInstructions: 遵循PEP8并使用类型提示。
    groups:
      - read
      - - edit
        - fileRegex: \.py$
          description: 仅限Python文件
      - command
```

**JSON替代：**
```json
{
  "customModes": [{
    "slug": "code",
    "name": "💻 Code (项目特定)",
    "roleDefinition": "您是一位具有此项目特定约束的软件工程师。",
    "whenToUse": "此项目特定代码模式用于此项目中的Python任务。",
    "customInstructions": "遵循PEP8并使用类型提示。",
    "groups": [
      "read",
      ["edit", { "fileRegex": "\\.py$", "description": "仅限Python文件" }],
      "command"
    ]
  }]
}
```
项目特定覆盖优先于全局覆盖。

### 覆盖默认模式的常见用例
* **限制文件访问：** 将模式限制为特定文件类型。
* **专门化行为：** 为您的技术栈自定义专业知识。
* **添加自定义指令：** 集成项目标准。
* **更改可用工具：** 删除工具以防止不需要的操作。

:::tip
覆盖默认模式时，请仔细测试。在进行重大更改之前，请考虑备份配置。
:::

---

## 理解自定义模式中的正则表达式

正则表达式（`fileRegex`）提供对文件编辑权限的细粒度控制。

:::tip
**让Roo构建您的正则表达式模式**

无需手动编写复杂的正则表达式，询问Roo：
```
创建一个匹配JavaScript文件但排除测试文件的正则表达式模式
```
Roo将生成模式。记得调整它以适应YAML（通常单反斜杠）或JSON（双反斜杠）。
:::

当您指定`fileRegex`时，您正在创建一个文件路径必须匹配的模式。

**`fileRegex`的重要规则：**
*   **JSON中的转义：** 在JSON字符串中，反斜杠（`\`）必须双转义（例如，`\\.md$`）。
*   **YAML中的转义：** 在未引用或单引号的YAML字符串中，单个反斜杠通常足以用于正则表达式特殊字符（例如，`\\.md$`）。但是，引号字符串中的YAML正则表达式模式可能需要类似JSON的双转义。
*   **路径匹配：** 模式匹配工作区根目录的完整相对文件路径（例如，`src/components/button.js`）。
*   **区分大小写：** 正则表达式模式默认区分大小写。
*   **验证：** 无效的正则表达式模式将被拒绝，并显示"无效的正则表达式模式"错误消息。

**常见模式示例：**
在下表中，"模式（概念/YAML类）"列显示模式在YAML中的显示方式。对于JSON，记得双转义反斜杠。

| 模式（概念/YAML类） | JSON `fileRegex`值 | 匹配 | 不匹配 |
| ---------------- | ------------------------------- | ----------------------------------------- | ------------------------------------- |
| `\\.md$` | `"\\.md$"` | `readme.md`, `docs/guide.md` | `script.js`, `readme.md.bak` |
| `^src/.*` | `"^src/.*"` | `src/app.js`, `src/components/button.tsx` | `lib/utils.js`, `test/src/mock.js` |
| `\\.(css|scss)$` | `\\.(css|scss)$` | `styles.css`, `theme.scss` | `styles.less`, `styles.css.map` |
| `docs/.*\\.md$` | `"docs/.*\\.md$"` | `docs/guide.md`, `docs/api/reference.md` | `guide.md`, `src/docs/notes.md` |
| `^(?!.*(test|spec))\\.(js|ts)$` | `"^(?!.*(test|spec))\\.(js|ts)$"` | `app.js`, `utils.ts` | `app.test.js`, `utils.spec.js`, `app.jsx` |

**关键正则表达式构建块：**
*   `\\.`：匹配文字点。（YAML：`\\.`，JSON：`\\\\.`）
*   `$`：匹配字符串结尾。
*   `^`：匹配字符串开头。
*   `.*`：匹配任何字符（换行符除外）零次或多次。
*   `(a|b)`：匹配"a"或"b"。（例如，`\\.(js|ts)$`）
*   `(?!...)`：负向前瞻。

**测试您的模式：**
1.  在示例文件路径上测试。在线正则表达式测试器很有帮助。
2.  记住JSON与YAML的转义规则。
3.  从简单开始并构建复杂性。

:::info 错误处理
当模式尝试编辑不匹配其`fileRegex`模式的文件时，您将看到包含以下内容的`FileRestrictionError`：
- 模式名称
- 允许的文件模式
- 描述（如果提供）
- 尝试的文件路径
- 被阻止的工具

此信息帮助您理解为什么您的操作被阻止，以及当前模式允许哪些文件类型。
:::

---

## 附加功能

### 内置模式定制
导出内置模式（如Code、Architect、Ask、Debug）时，您所做的任何自定义都包含在导出中。这允许您与他人分享内置模式的个性化版本。

### 模式删除和规则
通过UI删除模式时，Roo Code会提示您删除关联的规则文件夹，在删除前显示确切路径。这有助于防止意外丢失自定义指令。

### 全局规则目录
除了模式特定规则目录外，还有一个通用的`.roo/rules/`目录（无模式后缀），可用于所有模式之间的共享规则。

### 故障排除

**常见问题：**
- **模式未出现：** 创建或导入模式后，您可能需要重新加载VS Code窗口才能使其出现在模式选择器中。
- **无效的正则表达式模式：** 如果您的`fileRegex`模式无效，您将收到错误消息。在应用前使用在线正则表达式测试器测试您的模式。
- **优先级混淆：** 记住项目模式完全覆盖具有相同slug的全局模式 - 不合并任何属性。

